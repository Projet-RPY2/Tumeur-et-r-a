#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Nov  9 16:14:50 2020

@author: karimbelarbi
"""

# Installation de l'environnement
pip install os
pip install rpy2
pip install plotnine
pip install pandas
pip install sklearn

import os
import rpy2
import numpy
import plotnine 
import pandas

from rpy2 import robjects
from rpy2.robjects.packages import importr # permettra d'importer la librairie

# importr("MASS")

# Définition du répertoire de travail
os.getcwd()
os.chdir("/Users/karimbelarbi/Google_Drive/M1_Data_Science_en_Santé/Djamel Zitouni/Projet rpy2")


# Chargement du fichier
# data = robjects.DataFrame.from_csvfile("export_data_1.csv", header = True, sep = ";", dec = ",")

# importation données en utilisant panda
data_pd = pandas.read_csv("export_data_1.csv", delimiter = ";", decimal = ",", encoding = "latin-1")
type(data_pd)
data_pd.head

# Première exploration du fichier data

# data.nrow
# data.ncol
data_pd.shape # pour voir dimension 299466 x 130
# print(robjects.r.str(data))

# [column.rclass[0] for column in data]

# print(data.colnames)
#print(data.rx(1, True))
# print(robjects.r.str(data))
# print(robjects.r.str(df))
#x = data.rx(10, True)
# print(x.rx2('POIDS_IDEAL')[0])
# robjects.r.mean(data[2])
# robjects.r.sd(data[2])
# rows_i = robjects.IntVector(range(1,5))
# subdata = data.rx(rows_i, True)
# print(subdata.nrow)

# subdata.to_csvfile(path = "export_data20.Csv", quote = True, sep = ";", eol='\n', na = 'NA', dec = ',', row_names = RTrue, qmethod = 'escape'', append = False')
# Enregistrement d'un sous fichier


# Extraction des interventions liées à des chirurgies carcinologiques

print(data_pd["LIB_DIAGNOSTIC"])
data_cancer = data_pd[data_pd['LIB_DIAGNOSTIC'].str.contains('cancer|tumeur|carcinome', case = False, na= False)]
    
set(data_cancer["LIB_DIAGNOSTIC"]) # pour vérifier les lib_diagnostics selectionnés
len(set(data_cancer["LIB_DIAGNOSTIC"])) # un total de 679 lib_diagnostics différents.

data_cancer.shape # pour avoir les dimensions 32232 x 130
list(data_cancer) # pour avoir les noms de colonnes

# Selection des variables d'interet pour l'étude

data_cancer = data_cancer[['ID_INTERVENTION', 'ID_PATIENT', 'AGE', 'CATEGORIE_AGE_ADULTE', 'POIDS', 'IMC', 'CATEGORIE_IMC_ADULTE', 'ASA', 'CATEGORIE_ASA', 'URGENCE', 'SEXE', 'DUREE_INTERVENTION', # J'ai ajouté ASA
                           'DUREE_BLOC', 'DUREE_ANESTHESIE', 'DUREE_INDUCTION_INCISION', 'LIB_DIAGNOSTIC', 'ENTREE_URGENCES', 'DUREE_SEJOUR_INTERV', 'DELAI_ENTREE_INTERV', 'DECES_SEJOUR_INTERV','REA_SI_POST_OP',  
                            'MOY_PNIM_BLOC_INDUC', 'MOY_PNIM_ANESTH', 'DOBUTAMINE',  'EPHEDRINE', 'NORADRENALINE', 'PHENYLEPHRINE', 'MOY_VCE_CHIR_POIDS_IDEAL', 'TOTAL_REMPLISSAGE']]

data_cancer.shape # pour avoir les dimensions 32232 x 29
list(data_cancer) # pour avoir les noms de colonnes 

# Correction des types de variables

# data_cancer = data_cancer.dropna() # Elimine toutes les interventions avec un NA n'importe ou. On perd trop de lignes
data_cancer = data_cancer.fillna(-1) # on remplie les champs NA par -1

data_cancer.columns # Affichage des variables
data_cancer.dtypes # Affichage des types de variables

convert_dict = {'ID_INTERVENTION': str, # création d'un dictionnaire attribuant à chaque colonne un type de valeurs
                'ID_PATIENT': str,
                'AGE': int,
                'CATEGORIE_AGE_ADULTE' : str,
                'POIDS': int,
                'IMC': float,
                'CATEGORIE_IMC_ADULTE': str,
                'ASA': int, # j'ai ajouté ASA
                'CATEGORIE_ASA': str,
                'URGENCE': bool,
                'SEXE': str,
                'DUREE_INTERVENTION': int,
                'DUREE_BLOC': int,
                'DUREE_ANESTHESIE': int,
                'DUREE_INDUCTION_INCISION' : int,
                'LIB_DIAGNOSTIC' : str,
                'ENTREE_URGENCES': bool,
                'DUREE_SEJOUR_INTERV': int,
                'DELAI_ENTREE_INTERV': int,
                'DECES_SEJOUR_INTERV': bool,
                'REA_SI_POST_OP': bool,
                'MOY_PNIM_BLOC_INDUC' : float,
                'MOY_PNIM_ANESTH': float,
                'DOBUTAMINE' : bool,
                'EPHEDRINE': bool,
                'NORADRENALINE': bool,
                'PHENYLEPHRINE': bool,
                'MOY_VCE_CHIR_POIDS_IDEAL': float,
                'TOTAL_REMPLISSAGE': int
               } 
    
data_cancer = data_cancer.astype(convert_dict) 

data_cancer = data_cancer.replace("-1",numpy.nan) # On remet les str "-1" en NA
data_cancer = data_cancer.replace(-1,numpy.nan) # On remet les -1 en NA

print(data_cancer.dtypes) 
data_cancer.shape # on a toujours dimensions 32232 x 29

pandas.unique(data_cancer['CATEGORIE_ASA'])

# Traitement des valeurs aberrantes

max(data_cancer['POIDS'])
min(data_cancer['POIDS']) 

data_cancer.loc[data_cancer['POIDS'] < 0, 'POIDS'] = numpy.nan
data_cancer.loc[data_cancer['POIDS'] > 250, 'POIDS'] = numpy.nan

data_cancer.loc[data_cancer['IMC'] < 5, 'IMC'] = numpy.nan
data_cancer.loc[data_cancer['IMC'] > 75, 'IMC'] = numpy.nan

data_cancer.loc[data_cancer['DELAI_ENTREE_INTERV'] < 0, 'DELAI_ENTREE_INTERV'] = numpy.nan
data_cancer.loc[data_cancer['DELAI_ENTREE_INTERV'] > 60, 'DELAI_ENTREE_INTERV'] = numpy.nan

data_cancer.loc[data_cancer['DUREE_INTERVENTION'] < 15, 'DUREE_INTERVENTION'] = numpy.nan
data_cancer.loc[data_cancer['DUREE_INTERVENTION'] > 1440, 'DUREE_INTERVENTION'] = numpy.nan

data_cancer.loc[ data_cancer['DUREE_BLOC'] < 15, 'DUREE_BLOC'] = numpy.nan
data_cancer.loc[ data_cancer['DUREE_BLOC'] > 1440, 'DUREE_BLOC'] = numpy.nan

data_cancer.loc[data_cancer['DUREE_ANESTHESIE'] < 0, 'DUREE_ANESTHESIE'] = numpy.nan
data_cancer.loc[data_cancer['DUREE_ANESTHESIE'] > 1440, 'DUREE_ANESTHESIE'] = numpy.nan

data_cancer.loc[ data_cancer['DUREE_INDUCTION_INCISION'] < 0, 'DUREE_INDUCTION_INCISION'] = numpy.nan

data_cancer.loc[ data_cancer['MOY_VCE_CHIR_POIDS_IDEAL'] < 0, 'MOY_VCE_CHIR_POIDS_IDEAL'] = numpy.nan

max(data_cancer['POIDS']) # 237
min(data_cancer['POIDS']) # 2


# Ajout de nouvelles variables

data_cancer['CATECHOLAMINE'] = (data_cancer['DOBUTAMINE'] == 1) | (data_cancer['EPHEDRINE'] == 1) | (data_cancer['NORADRENALINE'] == 1) | (data_cancer['PHENYLEPHRINE'] == 1)
# pandas.unique(data_cancer['CATHECOLAMINE'])
data_cancer.shape # pour avoir les dimensions 32232 x 30
list(data_cancer) #

## Vérification de la nouvelle variable "CATHECOLAMINE"
data_cancer[['DOBUTAMINE', 'EPHEDRINE', 'NORADRENALINE', 'PHENYLEPHRINE', 'CATECHOLAMINE']].head(50)

## Elimination des colonnes 'DOBUTAMINE', 'EPHEDRINE', 'NORADRENALINE', 'PHENYLEPHRINE'
data_cancer = data_cancer.drop(['DOBUTAMINE',  'EPHEDRINE', 'NORADRENALINE', 'PHENYLEPHRINE'], axis = 1) # axis = 1 pour colonnes
data_cancer.shape # pour avoir les dimensions 32232 x 26
list(data_cancer) # vérification nouvelle colonne "CATECHOLAMINE"

# Data visualization

data_cancer = data_cancer.replace('NA', numpy.nan)

# Pour faire tous les graphs de variables en fonction de rea_si_post_op # Changer xlab = hospitalisation en réanimation 
        
for i in data_cancer.drop(['ID_INTERVENTION', 'ID_PATIENT'], axis = 1).columns: # nom des colonnes à l'exclusion de ID_INTERVENTION et ID_PATIENT
    data_cancer_i = data_cancer[data_cancer[i].notna()] # on retire les enregistrements avec valeurs manquante pour la variable d'intéret
    if data_cancer_i[i].dtypes == int or data_cancer_i[i].dtypes == float:
        (plotnine.ggplot(data=data_cancer_i, # utilisation du dataset data_cancer
           mapping=plotnine.aes(x='REA_SI_POST_OP', y = i)) # definition de la variable à représenter en y
             + plotnine.geom_boxplot(na_rm=True)
             + plotnine.xlab("hospitalisation en réanimation")
             + plotnine.ylab(str(i.lower()))
             + plotnine.theme_538()).save(filename=i)
    elif data_cancer_i[i].dtypes == str or data_cancer_i[i].dtypes == bool:
        (plotnine.ggplot(data=data_cancer_i, # utilisation du dataset data_cancer
           mapping=plotnine.aes(x='REA_SI_POST_OP', fill = i)) # definition de la variable à représenter en y
             + plotnine.geom_bar(position = "fill", na_rm=True)
             + plotnine.xlab("hospitalisation en réanimation")
             + plotnine.ylab(str(i.lower()))
             + plotnine.scales.scale_color_brewer(type='seq', palette=1, direction=1)
             + plotnine.theme_538()).save(filename=i)

data_cancer.shape # 32232 x 26. 

# Obtention des descriptions des variables quantitatives des enregistrements rea et non_rea
data_cancer_rea = data_cancer.loc[data_cancer['REA_SI_POST_OP'] == 1]
data_cancer_non_rea = data_cancer.loc[data_cancer['REA_SI_POST_OP'] == 0]

## La fonction describe() permet de décrire toutes les variables quantitatives d'un jeu de données directement.
data_cancer_rea.describe().round(2).to_csv('data_cancer_rea_stats_descriptive.csv', sep = ';', decimal = ',', header = True, encoding = 'latin-1')
data_cancer_non_rea.describe().round(2).to_csv('data_cancer_non_rea_stats_descriptive.csv', sep = ';', decimal = ',', header = True, encoding = 'latin-1')

# Pour faire analyses statistiques de variables en fonction de rea_si_post_op dans R

# Export de data_cancer sous forme de csv 
data_cancer.to_csv('data_cancer_export.csv', sep = ';', decimal = ',', header = True, encoding = 'latin-1')  # exportation du fichier en format csv

# Importation de data_cancer dans R via rpy2
robjects.r("path = '/Users/karimbelarbi/Google_Drive/M1_Data_Science_en_Santé/Djamel Zitouni/Projet rpy2/'")
robjects.r("data_cancer = read.csv2(file.path(path, 'data_cancer_export.csv'), sep = ';', dec = ',', header = TRUE, encoding = 'latin1')")

# Correction des types de variables
robjects.r("""data_cancer$ID_INTERVENTION = as.character(data_cancer$ID_INTERVENTION)
data_cancer$ID_PATIENT = as.character(data_cancer$ID_PATIENT)
data_cancer$AGE = as.numeric(data_cancer$AGE)
data_cancer$CATEGORIE_AGE_ADULTE = as.factor(data_cancer$CATEGORIE_AGE_ADULTE)
data_cancer$POIDS = as.integer(data_cancer$POIDS)
data_cancer$IMC = as.integer(data_cancer$IMC)
data_cancer$CATEGORIE_IMC_ADULTE = as.factor(data_cancer$CATEGORIE_IMC_ADULTE)
data_cancer$ASA = as.factor(data_cancer$ASA)
data_cancer$CATEGORIE_ASA = as.factor(data_cancer$CATEGORIE_ASA)
data_cancer$URGENCE = as.factor(data_cancer$URGENCE)
data_cancer$SEXE = as.character(data_cancer$SEXE)
data_cancer$DUREE_INTERVENTION = as.integer(data_cancer$DUREE_INTERVENTION)
data_cancer$DUREE_BLOC = as.integer(data_cancer$DUREE_BLOC)
data_cancer$DUREE_ANESTHESIE = as.integer(as.integer(data_cancer$DUREE_ANESTHESIE))
data_cancer$DUREE_INDUCTION_INCISION = as.integer(data_cancer$DUREE_INDUCTION_INCISION)
data_cancer$LIB_DIAGNOSTIC = as.factor(data_cancer$LIB_DIAGNOSTIC)
data_cancer$ENTREE_URGENCES = as.factor(data_cancer$ENTREE_URGENCES)
data_cancer$DUREE_SEJOUR_INTERV = as.integer(data_cancer$DUREE_SEJOUR_INTERV)
data_cancer$DELAI_ENTREE_INTERV = as.integer(data_cancer$DELAI_ENTREE_INTERV)
data_cancer$DECES_SEJOUR_INTERV = as.factor(data_cancer$DECES_SEJOUR_INTERV)
data_cancer$REA_SI_POST_OP = as.factor(data_cancer$REA_SI_POST_OP)
data_cancer$MOY_PNIM_BLOC_INDUC = as.numeric(data_cancer$MOY_PNIM_BLOC_INDUC)
data_cancer$MOY_PNIM_ANESTH = as.numeric(data_cancer$MOY_PNIM_ANESTH)
data_cancer$MOY_VCE_CHIR_POIDS_IDEAL  = as.numeric(data_cancer$MOY_VCE_CHIR_POIDS_IDEAL)
data_cancer$TOTAL_REMPLISSAGE = as.numeric(data_cancer$TOTAL_REMPLISSAGE)
data_cancer$CATECHOLAMINE = as.factor(data_cancer$CATECHOLAMINE)""")

robjects.r("str(data_cancer)") # vérification du type de variables

# Analyse statistique

# Test Wilcoxon
# HO = hypothèse de distribution identique de la variable entre groupes REA_SI_POST_OP ou non REA_SI_POST_OP
# H1 = distribution différente de la variable  entre groupes REA_SI_POST_OP ou non REA_SI_POST_OP

robjects.r("""        
           resultat = data.frame()
           nom_variable = vector()
           classe_variable = vector()
           nom_test = vector()
           p_value = vector()
           """)

robjects.r("""
    for (i in names(data_cancer)) { 
            if (class(data_cancer[,i]) == "integer"|class(data_cancer[,i]) == "numeric") {
                    test = wilcox.test(data_cancer[,i] ~ data_cancer$REA_SI_POST_OP, paired = FALSE, alternative = "two.sided", na.action = na.omit)
                    nom_variable[i] = as.character(i)
                    classe_variable[i] = class(data_cancer[,i])
                    nom_test[i] = "wilcox.test"
                    p_value[i] = test$p.value   
                    }      
   }
    resultat_wilcox = data.frame(nom_variable, classe_variable, nom_test, p_value)   
""")           

print(robjects.r("resultat_wilcox"))




#########
##########
# on supprime toutes les données manquantes 
data_cancer_na = data_cancer.dropna()                 # j'ai remplacé la ligne 122 par :data_cancer = data_cancer.replace(-1,numpy.nan)   #Oui c'est bien !

#traitement sur ASA a faire
#supprime les 3 premiers caracteres pour la variable ASA (ASA1, ASA2, ASA3, ASA4)
#data_cancer_na['ASA'] = data_cancer_na['ASA'].str[3:]

#Choix des variables a intégrer dans le modele
data_cancer_rl = data_cancer_na[['AGE', 'POIDS', 'IMC','ASA', 'URGENCE', 'SEXE', 'DUREE_INTERVENTION','DUREE_BLOC', 'DUREE_ANESTHESIE', 'DUREE_INDUCTION_INCISION', 'ENTREE_URGENCES', 'DUREE_SEJOUR_INTERV', 'DELAI_ENTREE_INTERV', 'DECES_SEJOUR_INTERV','REA_SI_POST_OP', 'MOY_PNIM_ANESTH', 'CATHECOLAMINE','MOY_VCE_CHIR_POIDS_IDEAL', 'TOTAL_REMPLISSAGE']]
data_cancer_rl.shape # 8427 x 19
predictors =['AGE', 'IMC','ASA','URGENCE', 'SEXE', 'DUREE_INTERVENTION', 'DUREE_BLOC','ENTREE_URGENCES', 'DELAI_ENTREE_INTERV','MOY_PNIM_ANESTH','CATHECOLAMINE', 'MOY_VCE_CHIR_POIDS_IDEAL','TOTAL_REMPLISSAGE']

#Creation des 2 echantillons 
data_cancer_rea = data_cancer_rl.loc[data_cancer_rl['REA_SI_POST_OP'] == 1]
data_cancer_non_rea = data_cancer_rl.loc[data_cancer_rl['REA_SI_POST_OP'] == 0]

data_cancer_rea.shape # (1640, 19)
data_cancer_non_rea.shape # (6787, 19)

#On ajuste les 2 echantillons pour qu'ils aient la meme taille : évite les désiquilibres et imprécisions
data_cancer_non_rea=shuffle(data_cancer_non_rea)
data_cancer_non_rea = data_cancer_non_rea.iloc[0:1500,:]            #6787 vs 1640 
df = pandas.concat([data_cancer_rea,data_cancer_non_rea],axis=0)

#shuffle permet de mélanger au hasard les lignes du df
from sklearn.utils import shuffle
df = shuffle(data_cancer_rl)

#scatterplot pour visualiser les variables que l'on souhaite garder
data_cancer_rl.plot.scatter(x='REA_SI_POST_OP',y='AGE')
data_cancer_rl.boxplot(column='AGE',by='REA_SI_POST_OP')
data_cancer_rl.boxplot(column='DUREE_INTERVENTION',by='REA_SI_POST_OP')
data_cancer_rl.boxplot(column='DUREE_BLOC',by='REA_SI_POST_OP')


#Selection des variables a expliquer et de la variable explicative
### Faudrait revoir avec Oriane les variables pré-op et susceptible d'influencer, ci dessous et ligne 87.
### pourquoi ne pas faire X = df["VAR1", "VAR2"...] plutôt que drop ? Je ne suis pas sur.     
X = df.drop(['REA_SI_POST_OP','POIDS', 'DUREE_ANESTHESIE', 'DUREE_INDUCTION_INCISION','DECES_SEJOUR_INTERV'],axis=1)    #A REVOIR
Y = df["REA_SI_POST_OP"]

#one hot encoder permet de recoder le score asa en int
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
X = X.iloc[:,:].values
labelencoder_X_1 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
print(X)


#mise à l'echelle des valeurs (évite les erreurs de standardisation)
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X = sc.fit_transform(X)
X = sc.transform(X)

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression

#on divise les données en 3 sous-ensembles aléatoires(train, valid, test )
#train pour entrainer le modele, valid pour vvalider le modele et test pour tester le modele
#test_size = 0.2 (20% des données vont être utilisées pour tester le modele)
#train_size est par defaut a None (80% des données vont être utilisées pour entrainer le modele)

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
X_test, X_valid, y_test, y_valid = train_test_split(X_test, y_test, test_size=0.2)

#creation de la regression logistique
clf = LogisticRegression(random_state=0, solver='lbfgs',multi_class='auto', max_iter=100000).fit(X_train, y_train)

clf.predict(X_test)   # correspond aux valeurs prédites (type bool)
#on verifie la correlation entre les valeurs predites et les valeurs attendues (fiabilité du modele)
clf.score(X_test, y_test)   #0.85

#matrice de correlation pour verifier si il y a intercorrélation entre les variabel explicatives
corr_matrix = data_cancer_rl.corr()
import matplotlib.pyplot as plt

import seaborn as sns; sns.set()
plt.figure(figsize = (20,10))
sns.heatmap(corr_matrix,annot=True)
plt.show()


### Courbe AUC

#calcul des probabilités 
from sklearn.metrics import roc_curve, auc
probas = clf.predict_proba(X_test)

#vecteur des probas par rapport aux valeurs attendues
rep = [ ]
yt = y_test.ravel()
for i in range(probas.shape[0]):
    p0,p1 = probas[i,:]
    exp = yt[i]
    if p0 > p1 :
        if exp == 0 :
            # bonne réponse
            rep.append ( (1, p0) )
        else :
            # mauvaise réponse
            rep.append( (0,p0) )
    else :
        if exp == 0 :
            # mauvaise réponse
            rep.append ( (0, p1) )
        else :
            # bonne réponse
            rep.append( (1,p1) )
            
mat_rep = numpy.array(rep)
mat_rep[:5]  #a gauche y_test ; a droite la proba associée

#"taux de bonne prediction",sum(mat_rep[:,0]/len(mat_rep)) # 0.85

fpr, tpr, thresholds = roc_curve(mat_rep[:,0], mat_rep[:, 1])
roc_auc = auc(fpr, tpr)
plt.plot(fpr, tpr, label='Courbe AUC (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], 'k--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.0])
plt.xlabel('Taux de faux positif')
plt.ylabel('Taux de vrai positif')
plt.title('AUC')
plt.legend(loc="lower right")

#On test avec les echantillons tirés au hasard 
import random
Y1 = numpy.array([ random.randint(0,1) == 0 for i in range(0,mat_rep.shape[0]) ]) #premier echantillon
Y2 = numpy.array([ random.randint(0,1) == 0 for i in range(0,mat_rep.shape[0]) ]) #deuxieme echantillon

fpr1, tpr1, thresholds1 = roc_curve(mat_rep[Y1,0], mat_rep[Y1, 1])
roc_auc1 = auc(fpr1, tpr1)
fpr2, tpr2, thresholds2 = roc_curve(mat_rep[Y2,0], mat_rep[Y2, 1])
roc_auc2 = auc(fpr2, tpr2)
print(fpr1.shape,tpr1.shape,fpr2.shape,tpr2.shape)

#on trace l'AUC des 2 autres echantillons pour verifier le modele
import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.plot(fpr, tpr, label='Courbe AUC (area = %0.2f)' % roc_auc)
ax.plot([0, 1,2], [0, 1,2], 'k--')
ax.set_xlim([0.0, 1.0])
ax.set_ylim([0.0, 1.0])
ax.set_xlabel('Taux de faux positif')
ax.set_ylabel('Taux de vrai positif')
ax.set_title('AUC')
ax.plot(fpr1, tpr1, label='ech 1, area=%0.2f' % roc_auc1)
ax.plot(fpr2, tpr2, label='ech 2, area=%0.2f' % roc_auc2)
ax.legend(loc="lower right")

#AUC compris environ entre 0.77 et 0.85 

# matrice de confusion (mesure la qualité du modelele)
from sklearn import metrics
cnf_matrix = metrics.confusion_matrix(y_test, y_pred)
cnf_matrix

# visualisation de la matrice
%matplotlib inline
class_names=[0,1] 
fig, ax = plt.subplots()
tick_marks = numpy.arange(len(class_names))
plt.xticks(tick_marks, class_names)
plt.yticks(tick_marks, class_names)

sns.heatmap(pandas.DataFrame(cnf_matrix), annot=True, cmap="YlGnBu" ,fmt='g')
ax.xaxis.set_label_position("top")
plt.tight_layout()
plt.title('Confusion matrix', y=1.1)
plt.ylabel('Actual label')
plt.xlabel('Predicted label')

#Coefficients B0^ du modele
predictors =['AGE', 'IMC','ASA','URGENCE', 'SEXE', 'DUREE_INTERVENTION', 'DUREE_BLOC','ENTREE_URGENCES', 'DELAI_ENTREE_INTERV','MOY_PNIM_ANESTH','CATHECOLAMINE', 'MOY_VCE_CHIR_POIDS_IDEAL','TOTAL_REMPLISSAGE']

clf.fit(X, Y)
coef = clf.coef_
for p,c in zip(predictors,list(coef[0])):
    print(p + '\t' + str(c))


